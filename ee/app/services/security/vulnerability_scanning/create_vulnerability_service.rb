# frozen_string_literal: true

module Security
  module VulnerabilityScanning
    class CreateVulnerabilityService
      # Create a Vulnerabilities::Finding from an SBOM component, and vulnerability advisory.
      #
      # @param project [Project]
      # @param pipeline [Ci::Pipeline]
      # @param params [Hash]
      # @option params [::Gitlab::Ci::Reports::Sbom::Source, Sbom::Source] :sbom_source
      # @option params [::Gitlab::VulnerabilityScanning::Advisory] :advisory
      # @option params [Array<::Gitlab::VulnerabilityScanning::AffectedComponent>] :affected_components
      #
      # @return [ServiceResponse] If successful, the service response payload contains
      #   a `vulnerability_id` key with the id of the new vulnerability. Otherwise, the
      #   payload contains the error raised during execution.
      def self.execute(...)
        new(...).execute
      end

      def initialize(project:, pipeline:, params:)
        @project = project
        @pipeline = pipeline
        @sbom_source = params[:sbom_source]
        @advisory = params[:advisory]
        @affected_components = params[:affected_components]
      end

      def execute
        if pipeline.user.nil?
          raise ArgumentError,
            'Pipeline must have a corresponding user to use as vulnerability author'
        end

        vulnerability_ids = ::Security::Ingestion::IngestReportSliceService.execute(pipeline, finding_maps)
        ServiceResponse.success(message: "Vulnerabilities were created",
          payload: { vulnerability_ids: vulnerability_ids })
      rescue StandardError => error
        process_error(error)
      end

      private

      attr_reader :project, :pipeline, :sbom_source, :advisory, :affected_components

      def report_scanner
        ::Gitlab::VulnerabilityScanning::SecurityScanner.fabricate
      end

      def project_scanner
        ::Gitlab::VulnerabilityScanning::SecurityScanner.find_or_create_for_project!(project)
      end

      def finding(affected_component)
        purl_type = affected_component.purl_type
        builder = ::Gitlab::VulnerabilityScanning::FindingBuilder.for_purl_type!(purl_type)
        builder.new(
          project: project,
          pipeline: pipeline,
          sbom_source: sbom_source,
          scanner: report_scanner,
          advisory: advisory,
          affected_component: affected_component
        ).finding
      end

      def finding_maps
        affected_components.map { |affected_component| FindingMap.new(finding(affected_component), project_scanner.id) }
      end

      def process_error(error)
        ::Gitlab::ErrorTracking.track_exception(error, project_id: project.id)
        ServiceResponse.error(message: "Vulnerabilities were not created", payload: { error: error })
      end
    end
  end
end
