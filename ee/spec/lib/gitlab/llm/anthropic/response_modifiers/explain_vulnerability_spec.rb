# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::Llm::Anthropic::ResponseModifiers::ExplainVulnerability, feature_category: :vulnerability_management do
  let(:ai_response) { {}.to_json }

  subject(:response_modifier) { described_class.new(ai_response) }

  shared_examples_for 'empty response error' do
    it 'parses content from the ai response' do
      expect(response_modifier.response_body).to eq('')
    end

    it 'returns empty errors' do
      expect(response_modifier.errors).to match_array("The response from the AI provider was empty.")
    end
  end

  context 'when no ai_response is passed' do
    it_behaves_like 'empty response error'
  end

  context 'when empty hash is passed' do
    let(:ai_response) { {}.to_json }

    it_behaves_like 'empty response error'
  end

  context 'when no message is passed' do
    let(:ai_response) { { 'completion' => nil }.to_json }

    it_behaves_like 'empty response error'
  end

  context 'when message is passed' do
    let(:message) { "hello" }
    let(:ai_response) { { 'completion' => message }.to_json }

    it 'parses content from the ai response' do
      expect(response_modifier.response_body).to eq(message)
    end

    it 'returns empty errors' do
      expect(response_modifier.errors).to be_empty
    end

    context 'and the message contains markdown headers' do
      let(:markdown) { "# Insecure Cookie in Response\n\n lorem ipsum" }
      let(:message) { "Here is the response for xyz\n\n#{markdown}" }

      it 'parses content from the ai response and clips up to the markdown' do
        expect(response_modifier.response_body).to eq markdown
      end

      it 'returns empty errors' do
        expect(response_modifier.errors).to be_empty
      end
    end
  end
end
