# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::VulnerabilityScanning::AdvisoryScanner, feature_category: :software_composition_analysis do
  let_it_be(:user) { create(:user) }

  let_it_be_with_reload(:affected_project) { create(:project) }
  let_it_be(:affected_pipeline) { create(:ci_pipeline, user: user, project: affected_project) }
  let_it_be(:affected_version) { create(:sbom_component_version, version: '0.9.0') }

  let_it_be(:affected_project_2) { create(:project) }
  # A user is required to attribute vulnerability creation to a user, hence the omission of a user
  # for the pipeline here.
  let_it_be(:invalid_affected_pipeline) { create(:ci_pipeline, project: affected_project_2) }

  let_it_be(:unaffected_project) { create(:project) }
  let_it_be(:unaffected_pipeline) { create(:ci_pipeline, user: user, project: unaffected_project) }
  let_it_be(:unaffected_version) { create(:sbom_component_version, version: '1.0.0') }

  let_it_be(:affected_package) do
    create(:pm_affected_package, package_name: 'eslint', purl_type: :npm, affected_range: '>=0.8.0 <1.0.0')
  end

  before_all do
    eslint = create(:sbom_component, name: 'eslint', purl_type: :npm)
    create(:sbom_occurrence, component: eslint, component_version: affected_version, pipeline: affected_pipeline)
    create(:sbom_occurrence, component: eslint, component_version: affected_version,
      pipeline: invalid_affected_pipeline)
    create(:sbom_occurrence, component: eslint, component_version: unaffected_version, pipeline: unaffected_pipeline)
  end

  describe '#execute' do
    before do
      allow(Time).to receive(:current).and_return(Time.new(2023, 11, 14, 0, 0, 0, '+00:00'))
      allow(Gitlab::VulnerabilityScanning::TrackCvsService).to receive(:new).and_call_original
      allow(Gitlab::AppJsonLogger).to receive(:debug).and_call_original
      allow(Gitlab::AppJsonLogger).to receive(:error).and_call_original

      described_class.scan_projects_for(affected_package.advisory)
    end

    context 'when the projects have cvs_enabled' do
      before_all do
        affected_project.security_setting.update!(continuous_vulnerability_scans_enabled: true)
        affected_project_2.security_setting.update!(continuous_vulnerability_scans_enabled: true)
      end

      it 'creates a vulnerability in the affected project' do
        advisory = affected_package.advisory
        vulnerabilities = affected_project.vulnerabilities

        expect(vulnerabilities).to match_array([
          have_attributes(
            author_id: user.id,
            project_id: affected_pipeline.project.id,
            state: 'detected',
            confidence: 'unknown',
            report_type: 'dependency_scanning',
            present_on_default_branch: true,
            title: advisory.title,
            severity: advisory.cvss_v3.severity.downcase,
            finding_description: advisory.description,
            solution: affected_package.solution
          )
        ])

        expect(Gitlab::AppJsonLogger).to have_received(:debug).with(
          message: 'Successfully created vulnerability on advisory ingestion',
          project_id: affected_project.id, source_xid: 'glad', advisory_xid: advisory.advisory_xid)

        expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
          advisory: advisory,
          start_time: Time.current.iso8601,
          end_time: Time.current.iso8601,
          counts: {
            possibly_affected_projects: 2,
            known_affected_projects: 2,
            possibly_affected_sbom_occurrences: 2,
            known_affected_sbom_occurrences: 2
          }
        )
      end

      it 'does not create a vulnerability in the unaffected project' do
        vulnerabilities = unaffected_project.vulnerabilities
        expect(vulnerabilities).to be_empty
        expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
          advisory: affected_package.advisory,
          start_time: Time.current.iso8601,
          end_time: Time.current.iso8601,
          counts: {
            possibly_affected_projects: 2,
            known_affected_projects: 2,
            possibly_affected_sbom_occurrences: 2,
            known_affected_sbom_occurrences: 2
          }
        )
      end

      it 'logs error message when it encounters an error' do
        expect(Gitlab::AppJsonLogger).to have_received(:error).with(
          message: 'Failed to create vulnerability on advisory ingestion',
          error: anything, project_id: affected_project_2.id, source_xid: 'glad',
          advisory_xid: affected_package.advisory.advisory_xid)
      end
    end

    context 'when the projects do not have cvs_enabled' do
      it 'does not create a vulnerability in the affected project' do
        expect(affected_project.vulnerabilities).to be_empty
        expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
          advisory: affected_package.advisory,
          start_time: Time.current.iso8601,
          end_time: Time.current.iso8601,
          counts: {
            possibly_affected_projects: 0,
            known_affected_projects: 0,
            possibly_affected_sbom_occurrences: 0,
            known_affected_sbom_occurrences: 0
          }
        )
      end
    end
  end
end
