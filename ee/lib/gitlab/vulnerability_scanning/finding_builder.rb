# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    class FindingBuilder
      include Gitlab::Utils::StrongMemoize

      def self.for_report_type(report_type)
        return unless report_type == "dependency_scanning"

        ::Gitlab::VulnerabilityScanning::DependencyScanning::FindingBuilder
      end

      # .for_purl_type will return a builder for the given purl type if it exists.
      def self.for_purl_type(purl_type)
        return unless DEPENDENCY_SCANNING_PURL_TYPES.include?(purl_type)

        ::Gitlab::VulnerabilityScanning::DependencyScanning::FindingBuilder
      end

      # .for_purl_type! is exactly like .for_purl_type but will raise an error
      # if a builder does not exist for the purl type.
      def self.for_purl_type!(purl_type)
        builder_class = for_purl_type(purl_type)

        if builder_class.blank?
          raise StandardError,
            "No finding builder found for component with purl type '#{purl_type}'"
        end

        builder_class
      end

      def initialize(project:, pipeline:, sbom_source:, scanner:, advisory:, affected_component:)
        @project = project
        @pipeline = pipeline
        @sbom_source = sbom_source
        @scanner = scanner
        @advisory = advisory
        @affected_component = affected_component
      end

      def finding
        validate!

        ::Gitlab::Ci::Reports::Security::Finding.new(
          uuid: uuid,
          report_type: report_type,
          name: title,
          compare_key: '',
          location: location,
          evidence: nil,
          severity: ::Enums::Vulnerability.parse_severity_level(severity),
          confidence: 'unknown',
          scanner: scanner,
          scan: nil,
          identifiers: identifiers,
          links: links,
          original_data: original_data,
          metadata_version: metadata_version,
          details: details,
          project_id: project.id,
          found_by_pipeline: pipeline)
      end
      strong_memoize_attr :finding

      private

      DEPENDENCY_SCANNING_PURL_TYPES = %w[
        composer
        conan
        gem
        golang
        maven
        npm
        nuget
        pypi
      ].freeze

      attr_reader :project, :pipeline, :sbom_source, :scanner, :advisory, :affected_component

      def validate!
        raise NoMethodError, "#{self.class}#validate! is not implemented"
      end

      def report_type
        raise NoMethodError, "#{self.class}#report_type is not implemented"
      end

      def uuid
        uuid_v5_name_components = {
          report_type: report_type,
          primary_identifier_fingerprint: primary_identifier&.fingerprint,
          location_fingerprint: location_fingerprint,
          project_id: project.id
        }

        # Inline the comparison to squeeze out some performance
        if primary_identifier&.fingerprint.nil? ||
            location_fingerprint.nil?
          Gitlab::AppJsonLogger.warn(message: "One or more UUID name components are nil",
            components: uuid_v5_name_components)
          return
        end

        ::Security::VulnerabilityUUID.generate(
          report_type: uuid_v5_name_components[:report_type],
          primary_identifier_fingerprint: uuid_v5_name_components[:primary_identifier_fingerprint],
          location_fingerprint: uuid_v5_name_components[:location_fingerprint],
          project_id: uuid_v5_name_components[:project_id]
        )
      end

      def primary_identifier
        identifiers.first
      end

      def location_fingerprint
        location&.fingerprint
      end

      def identifiers
        advisory.identifiers.map do |identifier|
          ::Gitlab::Ci::Reports::Security::Identifier.new(
            external_type: identifier['type'],
            external_id: identifier['value'],
            name: identifier['name'],
            url: identifier['url'])
        end
      end
      strong_memoize_attr :identifiers

      def title
        identifier = identifiers.find(&:cve?) || identifiers.find(&:cwe?) || identifiers.first

        if location&.fingerprint_path
          "#{identifier.name} in #{location.fingerprint_path}"
        else
          identifier.name.to_s
        end
      end
      strong_memoize_attr :title

      def links
        advisory.urls.map { |url| ::Gitlab::Ci::Reports::Security::Link.new(name: nil, url: url) }
      end

      def severity
        advisory.cvss_v3&.severity&.downcase || advisory.cvss_v2&.severity&.downcase
      end
      strong_memoize_attr :severity

      def details
        {}
      end

      def location
        raise NoMethodError, "#{self.class}#location is not implemented"
      end

      def original_data
        raise NoMethodError, "#{self.class}#original_data is not implemented"
      end

      def metadata_version
        "0.0.0"
      end
      strong_memoize_attr :metadata_version
    end
  end
end
