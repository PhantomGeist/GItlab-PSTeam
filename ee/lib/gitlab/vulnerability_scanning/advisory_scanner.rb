# frozen_string_literal: true

module Gitlab
  module VulnerabilityScanning
    class AdvisoryScanner
      include Gitlab::Utils::StrongMemoize

      # Scans eligible projects that contain software components affected
      # by an advisory. If affected, it creates new vulnerabilities in the
      # project.
      #
      # @param advisory [PackageMetadata::Advisory]
      def self.scan_projects_for(advisory)
        new(advisory).execute
      end

      # Create a new advisory scanner instance.
      #
      # @param advisory [PackageMetadata::Advisory] The new advisory to scan projects for.
      #
      # @return [Gitlab::VulnerabilityScanning::AdvisoryScanner]
      def initialize(advisory)
        @advisory = advisory
      end

      def execute
        start_time = Time.current.iso8601
        possibly_affected_sbom_occurrences_count = 0
        known_affected_sbom_occurrences_count = 0
        possibly_affected_projects = {}
        known_affected_projects = {}

        advisory.affected_packages.each do |affected_package|
          advisory_data_object = vulnerability_scanning_advisory(solution: affected_package.solution)
          ::Sbom::PossiblyAffectedOccurrencesFinder.new(purl_type: affected_package.purl_type,
            package_name: affected_package.package_name).execute_in_batches do |batch|
            batch.each do |occurrence|
              possibly_affected_sbom_occurrences_count += 1
              possibly_affected_projects[occurrence.project.id] = true

              next unless occurrence_is_affected?(
                purl_type: affected_package.purl_type,
                range: affected_package.affected_range,
                version: occurrence.version)

              known_affected_sbom_occurrences_count += 1
              known_affected_projects[occurrence.project.id] = true

              affected_component = Gitlab::VulnerabilityScanning::PossiblyAffectedComponent
                .from_sbom_occurrence(occurrence)

              create_vulnerability(advisory_data_object, affected_component)
            end
          end
        end

        possibly_affected_projects_count = possibly_affected_projects.keys.size
        known_affected_projects_count = known_affected_projects.keys.size

        Gitlab::VulnerabilityScanning::TrackCvsService.new(
          advisory: advisory,
          start_time: start_time,
          end_time: Time.current.iso8601,
          counts: {
            possibly_affected_projects: possibly_affected_projects_count,
            known_affected_projects: known_affected_projects_count,
            possibly_affected_sbom_occurrences: possibly_affected_sbom_occurrences_count,
            known_affected_sbom_occurrences: known_affected_sbom_occurrences_count
          }
        ).execute
      end

      private

      attr_reader :advisory

      def occurrence_is_affected?(purl_type:, range:, version:)
        Gitlab::VulnerabilityScanning::AffectedVersionRangeMatcher.affected?(
          purl_type: purl_type, range: range, version: version)
      end

      def vulnerability_scanning_advisory(solution:)
        Gitlab::VulnerabilityScanning::Advisory.new(
          xid: advisory.advisory_xid,
          title: advisory.title,
          description: advisory.description,
          identifiers: advisory.identifiers,
          urls: advisory.urls,
          cvss_v2: advisory.cvss_v2,
          cvss_v3: advisory.cvss_v3,
          solution: solution
        )
      end

      def create_vulnerability(advisory, affected_component)
        response = ::Security::VulnerabilityScanning::CreateVulnerabilityService.execute(
          project: affected_component.project,
          pipeline: affected_component.pipeline,
          params: { sbom_source: affected_component.source, advisory: advisory,
                    affected_components: [affected_component] })

        if response.success?
          log_success(affected_component.project.id)
        else
          log_error(response.payload[:error], affected_component.project.id)
        end
      end

      def log_success(project_id)
        Gitlab::AppJsonLogger.debug(message: "Successfully created vulnerability on advisory ingestion",
          project_id: project_id, source_xid: advisory.source_xid, advisory_xid: advisory.advisory_xid)
      end

      def log_error(error, project_id)
        Gitlab::AppJsonLogger.error(message: "Failed to create vulnerability on advisory ingestion", error: error,
          project_id: project_id, source_xid: advisory.source_xid, advisory_xid: advisory.advisory_xid)
      end
    end
  end
end
